# Just A Note
#### Video Demo:  <(https://youtu.be/PvYF0cRwzsA)>
#### Description: Just A Note is a full stack web application that uses Python, Flask, HTMl, and CSS. The backend is done using Flask and Python, while the frontend is done using HTML and CSS. The web app allows new users to register for an account with an email, name, password, and confirmation. Returning users can simply log in with their email and password. The passwords are stored using a password hash to meet standards for password storage. After logging in or registering, users can access their notes, which are also saved in a database. Users can choose to add a new note, edit their existing note(s), or delete their existing note(s). The Add Note button simply adds the note that the user has typed in the text box. The edit button takes the user to a new page where they can enter a new note in place of the existing note that they wish to edit. The delete button simply removes the note from the user's notes. The full project contains a number of files, starting with a CSS file that houses the formatting and styling used in the web application. The different HTML files include the layout page and the different web app pages, including the home page, or index, edit page, login page, and register page. The layout page includes the reference to the CSS file, navigation bar, and code that implements the functionality for the error or success messages. It also includes a conditional that only shows the Home and Logout tabs if the user is logged in, and shows the Login and Register tabs if the user is not logged in. Each page uses Jinja syntax to extend the layout page, ensuring consistent formatting. The main section of each page overrides the layout page to implement the specific body for each page of the web app. The python files comprise the backend and manipulation of the data supplied by the user. The init file imports views, auth, and models to initialize the web application along with the login manager. The auth file defines the pathways and functions for the different sections of the web app for the user before they are logged in. First, the login route contains a login function and can be accessed by method get and post. If the method is post, meaning the user entered their login, the email and password are noted using request.form.get, and the password is checked for validity. If there is an error, a flash message will be displayed and the user will be prompted to login again. Next, the logout route is very simple and contains a function that logs the user out of the page when clicked, returning them to the login page. The register route is the most complex. When the user reaches it by post, meaning they entered data, extensive error checking occurs on the entered email, name, password, and confirmation. Every field is first checked to ensure that the user entered something into the text input box. Other error checking includes checking if the email has already been used to register an existing account and checking for a minimum and maximum character count on the email and name. For the password and confirmation fields, the password must be above a certain number of characters, and the password and confirmation must match. If all of these fields are satisfied, the user is registered, adding the user's information to the database and logging them into the web application. The models file actually creates the databases that the application uses to log users into the app and stores their notes data. The views file contains the pages of the web app that are used after the user is logged in, including the home, or index, page and edit page. It includes the index, edit , and delete routes. For the home page, the index function in views.py performs error checking on the notes that the user is adding to their notes and flashes error messages if necessary. If the note passes this error checking, the note is added to the database and the user is directed to the home page again. For the edit route, the edit function gets the note that the user wishes to edit and takes them to a new page where they type in the new note. The function checks the user's input and replaces the previous note with the new, edited note and returns them to the home page. The delete route contains a delete function that simply deletes the selected note and return the user back to the notes home page. Finally, the app.py file runs the web application with Flask for the user by importing the create_app function from __init__.py.

